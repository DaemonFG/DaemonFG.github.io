<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指 Offer 05. 替换空格</title>
      <link href="/2020/08/26/jian-zhi-offer-05-ti-huan-kong-ge/"/>
      <url>/2020/08/26/jian-zhi-offer-05-ti-huan-kong-ge/</url>
      
        <content type="html"><![CDATA[<h3 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><ul><li><p>示例</p><pre><code>输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot;</code></pre></li><li><p>限制：</p><pre><code>0 &lt;= s 的长度 &lt;= 10000</code></pre></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>统计空格数count</li><li>用resize对字符串进行扩容</li><li>c从后往前，双指针查找位置，并替换</li></ul><h4 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h4><h5 id="Time-Complexity-Big-O-notation"><a href="#Time-Complexity-Big-O-notation" class="headerlink" title="Time Complexity (Big O notation)"></a>Time Complexity (Big O notation)</h5><ul><li>O(n)</li></ul><h5 id="Space-Complexity-Big-O-notation"><a href="#Space-Complexity-Big-O-notation" class="headerlink" title="Space Complexity (Big O notation)"></a>Space Complexity (Big O notation)</h5><ul><li>O(1)</li></ul><h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><pre class=" language-C++"><code class="language-C++">class Solution &#123;public:    string replaceSpace(string s) &#123;        int count = 0;            int oldSize = s.size();        for (int i = 0; i < oldSize; i++) &#123;            if (s[i] == ' ') count++;    //统计空格数量        &#125;        s.resize(s.size() + count * 2);        //字符串扩容        int newSize = s.size();        for (int i = oldSize - 1, j = newSize - 1;i < j;i--,j--) &#123;            if (s[i] != ' ') s[j] = s[i];    //旧位置移到新位置            else &#123;                s[j] = '0';                s[j-1] =  '2';                s[j-2] = '%';                j -= 2;        //*            &#125;        &#125;        return s;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 53 - II. 0～n-1中缺失的数字</title>
      <link href="/2020/08/24/jian-zhi-offer-53-ii-0-n-1-zhong-que-shi-de-shu-zi/"/>
      <url>/2020/08/24/jian-zhi-offer-53-ii-0-n-1-zhong-que-shi-de-shu-zi/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h4><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><ul><li><p>示例1</p><pre><code>输入: [0,1,3]输出: 2</code></pre></li><li><p>示例2</p><pre><code>输入: [0,1,2,3,4,5,6,7,9]输出: 8</code></pre></li><li><p>限制</p><pre><code>1 &lt;= 数组长度 &lt;= 10000</code></pre></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>有序考虑二分查找</li><li>观察得到缺失数字左侧nums[mid]==mid，令left=mid+1</li><li>否则缺失数字在mid左侧，令right=mid</li><li>return值应该是在最终值的左侧，即left</li></ul><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><ul><li><p>时间复杂度</p><ul><li>O(logn)</li></ul></li><li><p>空间复杂度</p><ul><li>O(1)</li></ul><pre class=" language-C++"><code class="language-C++">class Solution &#123;public:    int missingNumber(vector<int>& nums) &#123;        int left = 0;        int right = nums.size();        while (left < right) &#123;            int mid = left + (right -left) / 2;            if (nums[mid] == mid) left = mid + 1;            else right = mid;        &#125;        return left;    &#125;&#125;;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Search Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 53 - I. 在排序数组中查找数字 I</title>
      <link href="/2020/08/24/jian-zhi-offer-53-i-zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-i/"/>
      <url>/2020/08/24/jian-zhi-offer-53-i-zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-i/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h4><p>统计一个数字在排序数组中出现的次数。</p><ul><li><p>示例 1:</p><pre><code>- 输入: nums = [5,7,7,8,8,10], target = 8  输出: 2</code></pre></li><li><p>示例 2:</p><pre><code>输入: nums = [5,7,7,8,8,10], target = 6输出: 0</code></pre></li><li><p>限制：</p><pre><code>0 &lt;= 数组长度 &lt;= 50000</code></pre></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>有序数组首选二分查找</li><li>因为要统计次数，所以要考虑target重复</li><li>首先二分查找到target，再以target为中心，左右统计相同的个数</li></ul><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><ul><li><p>时间复杂度</p><ul><li>O(logn)</li></ul></li><li><p>空间复杂度</p><ul><li>O(1)</li></ul></li></ul><pre class=" language-C++"><code class="language-C++">class Solution &#123;public:    int search(vector<int>& nums, int target) &#123;        int start = 0;        int end = nums.size() - 1;        int p = -1;        while (start <= end) &#123;            int mid = start + (end - start) / 2;    //不写(start+end)/ 2是为了防止数字过大带来加法益处            if (nums[mid] == target) &#123;                p = mid;                break;            &#125; else if (nums[mid] > target) end = mid - 1;            else start = mid + 1;        &#125;        if (p == -1) return 0;        int low = p;        int high = p;        while ( low >= 0 && nums[low] == target) low-=1;    //此处如果写成(nums[low] == target &&  low >= 0) 会报越界，下一行同理        while ( high < nums.size() && nums[high] == target) high+=1;        return high - low -1;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Search Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 11.旋转数组的最小数字</title>
      <link href="/2020/08/21/jian-zhi-offer-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-zi/"/>
      <url>/2020/08/21/jian-zhi-offer-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-zi/</url>
      
        <content type="html"><![CDATA[<h3 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11.旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11.旋转数组的最小数字</a></h3><ul><li><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><ul><li>示例 1：</li></ul><pre><code>输入：[3,4,5,1,2]输出：1</code></pre><ul><li>示例 2：</li></ul><pre><code>输入：[2,2,2,0,1]输出：0</code></pre></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li><p>每个数组由两段有序数组组成，且第二段数组的最大值&lt;第一段数组的最大值，所以最小值一定在最右边的数组上。</p></li><li><p>对于有序数组，采用二分查找的思想，numbers[mid]与右侧值numbers[end]作比较</p><ul><li>如果numbers[mid] &gt; numbers[end]，说明mid取到了偏左的位置，此时让numbers[start]取numbers[mid]右边一个值，即start=mid+1</li><li>如果numbers[mid] &lt; numbers[end]，则将end移到mid，即end=mid</li><li>为了防止出现好几个相同的数，例如示例2，如果numbers[mid]==numbers[end]，将end左移，即end–</li></ul></li><li><p>一直循环到start和end相邻或相等</p></li></ul><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><ul><li><p>时间复杂度</p><ul><li>O(logn)</li></ul></li><li><p>空间复杂度</p><ul><li>O(1)</li></ul></li></ul><pre class=" language-C++"><code class="language-C++">class Solution &#123;public:    int minArray(vector<int>& numbers) &#123;        int start = 0;        int end = numbers.size() - 1;        while (start < end) &#123;            int mid = start + (end - start) / 2;            if (numbers[mid] > numbers[end]) start=mid+1;            else if (numbers[mid] < numbers[end]) end=mid;            else end--;        &#125;       return numbers[start];    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Search Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 03.数组中的重复数字</title>
      <link href="/2020/08/21/jian-zhi-offer-03-shu-zu-zhong-de-chong-fu-shu-zi/"/>
      <url>/2020/08/21/jian-zhi-offer-03-shu-zu-zhong-de-chong-fu-shu-zi/</url>
      
        <content type="html"><![CDATA[<h3 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h3><ul><li><p>找出数组中重复的数字。</p><ul><li>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</li><li><strong>示例 1：</strong></li></ul><pre><code>输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 </code></pre><ul><li><strong>限制：</strong></li></ul><pre><code>2 &lt;= n &lt;= 100000</code></pre></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>如果nums[i] != i，位置i处放得不是数字i，则利用swap()交换的方法将i换到nums[i]。</li><li>但如果位置nums[i]上已经等于nums[i]，则nums[i]就是重复数字。</li><li>如果nums[i]位置上第一次等于i，跳过。</li></ul><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><ul><li><p>时间复杂度</p><ul><li>O(n)</li></ul></li><li><p>空间复杂度</p><ul><li>O(1)</li></ul></li></ul><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    int findRepeatNumber(vector<int>& nums) &#123;        for(int i=0; i < nums.size(); i++) &#123;            if (nums[i]==i) continue;            if (nums[nums[i]] == nums[i]) return nums[i];            swap(nums[i],nums[nums[i]]);        &#125;        return 0;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Search Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
